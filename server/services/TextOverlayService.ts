import * as fs from "fs";
import * as path from "path";
import { GoogleGenAI, Modality } from "@google/genai";

interface TextOverlayRequest {
  imageUrl?: string;
  text: string;
  platform: string;
  style: 'modern' | 'bold' | 'minimal' | 'gradient' | 'shadow';
  position: 'top' | 'center' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  fontSize: number;
  textColor: string;
  backgroundColor?: string;
  opacity: number;
}

interface SocialGraphicDimensions {
  width: number;
  height: number;
  name: string;
}

export class TextOverlayService {
  private ai: GoogleGenAI;
  
  private socialFormats: { [key: string]: SocialGraphicDimensions } = {
    'instagram_post': { width: 1080, height: 1080, name: 'Instagram Post' },
    'instagram_story': { width: 1080, height: 1920, name: 'Instagram Story' },
    'facebook_post': { width: 1200, height: 630, name: 'Facebook Post' },
    'twitter_post': { width: 1200, height: 675, name: 'Twitter Post' },
    'pinterest_pin': { width: 1000, height: 1500, name: 'Pinterest Pin' },
    'tiktok_video': { width: 1080, height: 1920, name: 'TikTok Video' },
    'youtube_thumbnail': { width: 1280, height: 720, name: 'YouTube Thumbnail' },
    'linkedin_post': { width: 1200, height: 627, name: 'LinkedIn Post' }
  };

  constructor() {
    this.ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || "" });
  }

  async generateRealGraphic(productName: string, platform: string): Promise<any> {
    try {
      console.log('üé® Generating real AI graphic for platform:', platform);
      
      const format = this.socialFormats[platform];
      if (!format) {
        throw new Error(`Unsupported platform: ${platform}`);
      }

      // Check if GEMINI_API_KEY is available
      if (!process.env.GEMINI_API_KEY) {
        console.error('‚ùå GEMINI_API_KEY not found, falling back to SVG generation');
        return this.generateFallbackSVG(productName, platform);
      }

      // Create graphics directory if it doesn't exist
      const graphicsDir = path.join(process.cwd(), 'client', 'public', 'generated-graphics');
      if (!fs.existsSync(graphicsDir)) {
        fs.mkdirSync(graphicsDir, { recursive: true });
      }

      const timestamp = Date.now();
      const filename = `${platform}-real-graphic-${timestamp}.png`;
      const filePath = path.join(graphicsDir, filename);

      // Create a detailed prompt for Gemini AI image generation
      const prompt = `Create a professional social media marketing graphic for "${productName}". 
      
      Design requirements:
      - Platform: ${format.name} (${format.width}x${format.height}px)
      - High-quality, modern design suitable for affiliate marketing
      - Include the product prominently
      - Professional typography with the product name
      - Marketing-focused design with eye-catching visuals
      - Use modern color schemes and layouts
      - Optimized for social media engagement
      - Professional advertising aesthetic
      
      Style: Modern, clean, professional marketing design that would perform well on ${format.name}`;

      console.log('ü§ñ Sending prompt to Gemini AI...');
      
      // Generate image using Gemini 2.0 Flash with image generation
      const response = await this.ai.models.generateContent({
        model: "gemini-2.0-flash-preview-image-generation",
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        },
      });

      const candidates = response.candidates;
      if (!candidates || candidates.length === 0) {
        console.warn('‚ö†Ô∏è No image generated by AI, falling back to SVG');
        return this.generateFallbackSVG(productName, platform);
      }

      const content = candidates[0].content;
      if (!content || !content.parts) {
        console.warn('‚ö†Ô∏è No content parts in AI response, falling back to SVG');
        return this.generateFallbackSVG(productName, platform);
      }

      let imageGenerated = false;
      for (const part of content.parts) {
        if (part.text) {
          console.log('ü§ñ AI response:', part.text);
        } else if (part.inlineData && part.inlineData.data) {
          const imageData = Buffer.from(part.inlineData.data, "base64");
          fs.writeFileSync(filePath, imageData);
          console.log(`üì∏ Real graphic saved as ${filename}`);
          imageGenerated = true;
          break;
        }
      }

      if (!imageGenerated) {
        console.warn('‚ö†Ô∏è No image data received from AI, falling back to SVG');
        return this.generateFallbackSVG(productName, platform);
      }

      return {
        success: true,
        filename: filename,
        url: `/generated-graphics/${filename}`,
        platform: platform,
        dimensions: format,
        type: 'real-graphic'
      };

    } catch (error) {
      console.error('‚ùå Error generating real graphic:', error);
      console.log('üîÑ Falling back to SVG generation...');
      return this.generateFallbackSVG(productName, platform);
    }
  }

  private generateFallbackSVG(productName: string, platform: string): any {
    try {
      console.log('üé® Generating fallback SVG graphic for:', productName);
      
      const format = this.socialFormats[platform];
      const timestamp = Date.now();
      const filename = `${platform}-svg-graphic-${timestamp}.svg`;
      
      // Create graphics directory if it doesn't exist
      const graphicsDir = path.join(process.cwd(), 'client', 'public', 'generated-graphics');
      if (!fs.existsSync(graphicsDir)) {
        fs.mkdirSync(graphicsDir, { recursive: true });
      }
      
      const filePath = path.join(graphicsDir, filename);
      
      // Generate professional SVG with gradient backgrounds and proper text
      const svgContent = this.createProfessionalSVG(productName, format);
      
      fs.writeFileSync(filePath, svgContent);
      console.log(`üì∏ Fallback SVG saved as ${filename}`);
      
      return {
        success: true,
        filename: filename,
        url: `/generated-graphics/${filename}`,
        platform: platform,
        dimensions: format,
        type: 'svg-graphic'
      };
      
    } catch (error) {
      console.error('‚ùå Error generating fallback SVG:', error);
      throw new Error('Failed to generate both AI and SVG graphics');
    }
  }

  private createProfessionalSVG(productName: string, format: SocialGraphicDimensions): string {
    // Professional color schemes
    const colorSchemes = [
      { bg: '#667eea', accent: '#764ba2', text: '#ffffff' },
      { bg: '#f093fb', accent: '#f5576c', text: '#ffffff' },
      { bg: '#4facfe', accent: '#00f2fe', text: '#ffffff' },
      { bg: '#43e97b', accent: '#38f9d7', text: '#ffffff' },
      { bg: '#fa709a', accent: '#fee140', text: '#ffffff' },
      { bg: '#a8edea', accent: '#fed6e3', text: '#2d3748' },
      { bg: '#ffecd2', accent: '#fcb69f', text: '#2d3748' }
    ];
    
    const scheme = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];
    
    // Responsive font sizes based on platform
    const baseFontSize = format.width < 800 ? 28 : 36;
    const subFontSize = format.width < 800 ? 16 : 20;
    
    return `
      <svg width="${format.width}" height="${format.height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bgGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:${scheme.bg};stop-opacity:1" />
            <stop offset="100%" style="stop-color:${scheme.accent};stop-opacity:1" />
          </linearGradient>
          <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="0" dy="4" stdDeviation="8" flood-opacity="0.3"/>
          </filter>
        </defs>
        
        <!-- Background -->
        <rect width="100%" height="100%" fill="url(#bgGradient)"/>
        
        <!-- Decorative elements -->
        <circle cx="${format.width * 0.1}" cy="${format.height * 0.2}" r="${format.width * 0.05}" fill="rgba(255,255,255,0.1)"/>
        <circle cx="${format.width * 0.9}" cy="${format.height * 0.8}" r="${format.width * 0.03}" fill="rgba(255,255,255,0.1)"/>
        
        <!-- Main content area -->
        <rect x="${format.width * 0.1}" y="${format.height * 0.3}" 
              width="${format.width * 0.8}" height="${format.height * 0.4}" 
              rx="20" fill="rgba(255,255,255,0.15)" filter="url(#shadow)"/>
        
        <!-- Product name -->
        <text x="${format.width / 2}" y="${format.height * 0.45}" 
              text-anchor="middle" 
              font-family="Arial, sans-serif" 
              font-size="${baseFontSize}" 
              font-weight="bold" 
              fill="${scheme.text}"
              style="text-shadow: 0px 2px 4px rgba(0,0,0,0.3);">
          ${productName.length > 20 ? productName.substring(0, 20) + '...' : productName}
        </text>
        
        <!-- Call to action -->
        <text x="${format.width / 2}" y="${format.height * 0.55}" 
              text-anchor="middle" 
              font-family="Arial, sans-serif" 
              font-size="${subFontSize}" 
              fill="${scheme.text}"
              opacity="0.9">
          Shop Now & Save
        </text>
        
        <!-- Bottom badge -->
        <rect x="${format.width * 0.25}" y="${format.height * 0.75}" 
              width="${format.width * 0.5}" height="${format.height * 0.08}" 
              rx="15" fill="rgba(255,255,255,0.9)"/>
        <text x="${format.width / 2}" y="${format.height * 0.8}" 
              text-anchor="middle" 
              font-family="Arial, sans-serif" 
              font-size="${subFontSize * 0.8}" 
              font-weight="bold" 
              fill="#2d3748">
          Affiliate Marketing
        </text>
      </svg>
    `;
  }

  async generateSocialGraphic(request: TextOverlayRequest): Promise<any> {
    try {
      console.log('üé® Generating social graphic for platform:', request.platform);
      console.log('üé® Available formats:', Object.keys(this.socialFormats));
      
      const format = this.socialFormats[request.platform];
      if (!format) {
        throw new Error(`Unsupported platform: ${request.platform}. Available platforms: ${Object.keys(this.socialFormats).join(', ')}`);
      }

      // Create graphics directory if it doesn't exist
      const graphicsDir = path.join(process.cwd(), 'client', 'public', 'generated-graphics');
      if (!fs.existsSync(graphicsDir)) {
        fs.mkdirSync(graphicsDir, { recursive: true });
      }

      const timestamp = Date.now();
      const filename = `${request.platform}-graphic-${timestamp}.svg`;
      const filepath = path.join(graphicsDir, filename);

      // Generate SVG with text overlay
      const svg = this.createSVGWithTextOverlay(request, format);
      fs.writeFileSync(filepath, svg);

      return {
        success: true,
        graphicUrl: `/generated-graphics/${filename}`,
        platform: request.platform,
        dimensions: format,
        filename
      };
    } catch (error) {
      console.error('Error generating social graphic:', error);
      throw error;
    }
  }

  private createSVGWithTextOverlay(request: TextOverlayRequest, format: SocialGraphicDimensions): string {
    const { width, height } = format;
    const textLines = this.wrapText(request.text, this.calculateMaxCharactersPerLine(width, request.fontSize));
    
    // Calculate text positioning
    const lineHeight = request.fontSize * 1.2;
    const totalTextHeight = textLines.length * lineHeight;
    const { x, y } = this.calculateTextPosition(request.position, width, height, totalTextHeight);

    // Generate background if specified - ensure it's visible
    const backgroundRect = request.backgroundColor 
      ? `  <rect x="0" y="0" width="${width}" height="${height}" fill="${request.backgroundColor}" opacity="${Math.max(request.opacity, 0.8)}"/>`
      : `  <rect x="0" y="0" width="${width}" height="${height}" fill="rgba(0,0,0,0.7)"/>`;

    // Create text elements with styling and strong contrast
    // Use white stroke for dark backgrounds, black stroke for light backgrounds
    const strokeColor = request.backgroundColor === '#000000' || request.backgroundColor?.includes('rgb(0') ? '#ffffff' : '#000000';
    const textElements = textLines.map((line, index) => {
      const yPos = y + (index * lineHeight);
      return `  <text x="${x}" y="${yPos}" fill="${request.textColor}" font-size="${request.fontSize}" font-family="Arial, sans-serif" font-weight="${request.style === 'bold' ? 'bold' : 'normal'}" text-anchor="middle" stroke="${strokeColor}" stroke-width="3" paint-order="stroke fill" filter="url(#dropshadow)">${this.escapeXML(line)}</text>`;
    }).join('\n');

    return `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <filter id="dropshadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="2" dy="2" stdDeviation="3" flood-color="rgba(0,0,0,0.3)"/>
    </filter>
    <linearGradient id="textGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#ff6b6b"/>
      <stop offset="100%" style="stop-color:#4ecdc4"/>
    </linearGradient>
  </defs>
  <rect x="0" y="0" width="${width}" height="${height}" fill="#f0f0f0"/>
  ${backgroundRect}
  ${textElements}
</svg>`;
  }

  private wrapText(text: string, maxCharsPerLine: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';

    for (const word of words) {
      if ((currentLine + word).length <= maxCharsPerLine) {
        currentLine += (currentLine ? ' ' : '') + word;
      } else {
        if (currentLine) lines.push(currentLine);
        currentLine = word;
      }
    }
    if (currentLine) lines.push(currentLine);

    return lines;
  }

  private calculateMaxCharactersPerLine(width: number, fontSize: number): number {
    // Rough estimate: each character takes about 0.6 * fontSize pixels
    const charWidth = fontSize * 0.6;
    const maxChars = Math.floor((width * 0.8) / charWidth); // Use 80% of width for padding
    return Math.max(10, maxChars); // Minimum 10 characters
  }

  private calculateTextPosition(position: string, width: number, height: number, textHeight: number): { x: number, y: number } {
    const padding = 50;
    
    switch (position) {
      case 'top':
        return { x: width / 2, y: padding + 20 };
      case 'center':
        return { x: width / 2, y: (height - textHeight) / 2 + 20 };
      case 'bottom':
        return { x: width / 2, y: height - textHeight - padding };
      case 'top-left':
        return { x: padding, y: padding + 20 };
      case 'top-right':
        return { x: width - padding, y: padding + 20 };
      case 'bottom-left':
        return { x: padding, y: height - textHeight - padding };
      case 'bottom-right':
        return { x: width - padding, y: height - textHeight - padding };
      default:
        return { x: width / 2, y: height / 2 };
    }
  }

  private getTextStyling(style: string): string {
    switch (style) {
      case 'shadow':
        return 'filter="url(#dropshadow)"';
      case 'gradient':
        return 'fill="url(#textGradient)"';
      case 'bold':
        return 'font-weight="bold"';
      case 'minimal':
        return 'font-weight="300"';
      default:
        return '';
    }
  }

  private escapeXML(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  // Generate suggested text overlays for ad copy
  generateTextSuggestions(adCopy: any, platform: string): any[] {
    const suggestions = [];
    
    // Headlines as prominent overlays
    if (adCopy.headlines) {
      adCopy.headlines.forEach((headline: string, index: number) => {
        suggestions.push({
          id: `headline-${index}`,
          text: headline,
          style: 'bold',
          position: 'center',
          fontSize: this.getOptimalFontSize(platform, 'headline'),
          textColor: '#ffffff',
          backgroundColor: 'rgba(0,0,0,0.7)',
          opacity: 0.8,
          type: 'headline'
        });
      });
    }

    // CTAs as bottom overlays
    if (adCopy.ctas) {
      adCopy.ctas.forEach((cta: string, index: number) => {
        suggestions.push({
          id: `cta-${index}`,
          text: cta,
          style: 'shadow',
          position: 'bottom',
          fontSize: this.getOptimalFontSize(platform, 'cta'),
          textColor: '#ff6b6b',
          backgroundColor: 'rgba(255,255,255,0.9)',
          opacity: 0.9,
          type: 'cta'
        });
      });
    }

    return suggestions;
  }

  // Generate image concepts for social media graphics
  async generateImageConcepts(productName: string, productDescription: string, platforms: string[]): Promise<any> {
    try {
      const prompt = `Generate creative image concepts for social media marketing graphics for this product:

Product: ${productName}
Description: ${productDescription}

For each platform (${platforms.join(', ')}), suggest 3 different visual concepts that would work well for affiliate marketing. Focus on:

1. Visual composition ideas
2. Color schemes that convert well
3. Background concepts (lifestyle, product focus, minimalist, etc.)
4. Text overlay placement suggestions
5. Visual elements that build trust and drive clicks

Respond with structured JSON format:
{
  "concepts": [
    {
      "platform": "platform_name",
      "concept_id": 1,
      "title": "Concept Title",
      "description": "Detailed description of the visual concept",
      "visual_style": "modern/minimalist/lifestyle/product-focused",
      "color_scheme": ["#color1", "#color2", "#color3"],
      "background_type": "solid/gradient/lifestyle/product/texture",
      "text_placement": "top/center/bottom/overlay",
      "key_elements": ["element1", "element2", "element3"],
      "marketing_angle": "trust/urgency/lifestyle/features"
    }
  ]
}`;

      const response = await this.ai.models.generateContent({
        model: "gemini-2.5-pro",
        config: {
          responseMimeType: "application/json",
        },
        contents: prompt,
      });

      const result = JSON.parse(response.text || '{"concepts": []}');
      return result;
    } catch (error) {
      console.error('Error generating image concepts:', error);
      return this.generateFallbackConcepts(productName, platforms);
    }
  }

  // Fallback concepts if AI generation fails
  private generateFallbackConcepts(productName: string, platforms: string[]): any {
    const baseConcepts = [
      {
        title: "Product Showcase",
        description: "Clean product image with bold text overlay highlighting key benefits",
        visual_style: "product-focused",
        color_scheme: ["#ffffff", "#000000", "#ff6b6b"],
        background_type: "solid",
        text_placement: "bottom",
        key_elements: ["product image", "benefit text", "call-to-action"],
        marketing_angle: "features"
      },
      {
        title: "Lifestyle Context",
        description: "Product in real-world usage with lifestyle photography",
        visual_style: "lifestyle",
        color_scheme: ["#f8f9fa", "#495057", "#28a745"],
        background_type: "lifestyle",
        text_placement: "overlay",
        key_elements: ["lifestyle scene", "product in use", "social proof"],
        marketing_angle: "lifestyle"
      },
      {
        title: "Minimalist Appeal",
        description: "Clean, minimal design with strong typography and subtle product presence",
        visual_style: "minimalist",
        color_scheme: ["#ffffff", "#6c757d", "#007bff"],
        background_type: "gradient",
        text_placement: "center",
        key_elements: ["clean typography", "minimal graphics", "trust badges"],
        marketing_angle: "trust"
      }
    ];

    const concepts = platforms.flatMap((platform, platformIndex) => 
      baseConcepts.map((concept, conceptIndex) => ({
        platform,
        concept_id: conceptIndex + 1,
        ...concept
      }))
    );

    return { concepts };
  }

  private getOptimalFontSize(platform: string, textType: 'headline' | 'cta' | 'description'): number {
    const baseSizes = {
      headline: { base: 48, mobile: 36 },
      cta: { base: 32, mobile: 24 },
      description: { base: 24, mobile: 18 }
    };

    const isMobileFormat = ['instagram_story', 'tiktok_video'].includes(platform);
    return isMobileFormat ? baseSizes[textType].mobile : baseSizes[textType].base;
  }

  // Get available social media formats
  getSocialFormats(): { [key: string]: SocialGraphicDimensions } {
    return this.socialFormats;
  }
}