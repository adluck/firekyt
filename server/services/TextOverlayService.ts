import * as fs from "fs";
import * as path from "path";
import { GoogleGenAI, Modality } from "@google/genai";

interface TextOverlayRequest {
  imageUrl?: string;
  text: string;
  platform: string;
  style: 'modern' | 'bold' | 'minimal' | 'gradient' | 'shadow';
  position: 'top' | 'center' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  fontSize: number;
  textColor: string;
  backgroundColor?: string;
  opacity: number;
}

interface SocialGraphicDimensions {
  width: number;
  height: number;
  name: string;
}

export class TextOverlayService {
  private ai: GoogleGenAI;
  
  private socialFormats: { [key: string]: SocialGraphicDimensions } = {
    'instagram_post': { width: 1080, height: 1080, name: 'Instagram Post' },
    'instagram_story': { width: 1080, height: 1920, name: 'Instagram Story' },
    'facebook_post': { width: 1200, height: 630, name: 'Facebook Post' },
    'twitter_post': { width: 1200, height: 675, name: 'Twitter Post' },
    'pinterest_pin': { width: 1000, height: 1500, name: 'Pinterest Pin' },
    'tiktok_video': { width: 1080, height: 1920, name: 'TikTok Video' },
    'youtube_thumbnail': { width: 1280, height: 720, name: 'YouTube Thumbnail' },
    'linkedin_post': { width: 1200, height: 627, name: 'LinkedIn Post' }
  };

  constructor() {
    this.ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || "" });
  }

  async generateRealGraphic(productName: string, platform: string): Promise<any> {
    try {
      console.log('üé® Generating real AI graphic for platform:', platform);
      
      const format = this.socialFormats[platform];
      if (!format) {
        throw new Error(`Unsupported platform: ${platform}`);
      }

      // Create graphics directory if it doesn't exist
      const graphicsDir = path.join(process.cwd(), 'client', 'public', 'generated-graphics');
      if (!fs.existsSync(graphicsDir)) {
        fs.mkdirSync(graphicsDir, { recursive: true });
      }

      const timestamp = Date.now();
      const filename = `${platform}-real-graphic-${timestamp}.png`;
      const filePath = path.join(graphicsDir, filename);

      // Create a detailed prompt for Gemini AI image generation
      const prompt = `Create a professional social media marketing graphic for "${productName}". 
      
      Design requirements:
      - Platform: ${format.name} (${format.width}x${format.height}px)
      - High-quality, modern design suitable for affiliate marketing
      - Include the product prominently
      - Professional typography with the product name
      - Marketing-focused design with eye-catching visuals
      - Use modern color schemes and layouts
      - Optimized for social media engagement
      - Professional advertising aesthetic
      
      Style: Modern, clean, professional marketing design that would perform well on ${format.name}`;

      console.log('ü§ñ Sending prompt to Gemini AI...');
      
      // Generate image using Gemini 2.0 Flash with image generation
      const response = await this.ai.models.generateContent({
        model: "gemini-2.0-flash-preview-image-generation",
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        },
      });

      const candidates = response.candidates;
      if (!candidates || candidates.length === 0) {
        throw new Error('No image generated by AI');
      }

      const content = candidates[0].content;
      if (!content || !content.parts) {
        throw new Error('No content parts in AI response');
      }

      let imageGenerated = false;
      for (const part of content.parts) {
        if (part.text) {
          console.log('ü§ñ AI response:', part.text);
        } else if (part.inlineData && part.inlineData.data) {
          const imageData = Buffer.from(part.inlineData.data, "base64");
          fs.writeFileSync(filePath, imageData);
          console.log(`üì∏ Real graphic saved as ${filename}`);
          imageGenerated = true;
          break;
        }
      }

      if (!imageGenerated) {
        throw new Error('No image data received from AI');
      }

      return {
        success: true,
        filename: filename,
        url: `/generated-graphics/${filename}`,
        platform: platform,
        dimensions: format,
        type: 'real-graphic'
      };

    } catch (error) {
      console.error('‚ùå Error generating real graphic:', error);
      throw error;
    }
  }

  async generateSocialGraphic(request: TextOverlayRequest): Promise<any> {
    try {
      console.log('üé® Generating social graphic for platform:', request.platform);
      console.log('üé® Available formats:', Object.keys(this.socialFormats));
      
      const format = this.socialFormats[request.platform];
      if (!format) {
        throw new Error(`Unsupported platform: ${request.platform}. Available platforms: ${Object.keys(this.socialFormats).join(', ')}`);
      }

      // Create graphics directory if it doesn't exist
      const graphicsDir = path.join(process.cwd(), 'client', 'public', 'generated-graphics');
      if (!fs.existsSync(graphicsDir)) {
        fs.mkdirSync(graphicsDir, { recursive: true });
      }

      const timestamp = Date.now();
      const filename = `${request.platform}-graphic-${timestamp}.svg`;
      const filepath = path.join(graphicsDir, filename);

      // Generate SVG with text overlay
      const svg = this.createSVGWithTextOverlay(request, format);
      fs.writeFileSync(filepath, svg);

      return {
        success: true,
        graphicUrl: `/generated-graphics/${filename}`,
        platform: request.platform,
        dimensions: format,
        filename
      };
    } catch (error) {
      console.error('Error generating social graphic:', error);
      throw error;
    }
  }

  private createSVGWithTextOverlay(request: TextOverlayRequest, format: SocialGraphicDimensions): string {
    const { width, height } = format;
    const textLines = this.wrapText(request.text, this.calculateMaxCharactersPerLine(width, request.fontSize));
    
    // Calculate text positioning
    const lineHeight = request.fontSize * 1.2;
    const totalTextHeight = textLines.length * lineHeight;
    const { x, y } = this.calculateTextPosition(request.position, width, height, totalTextHeight);

    // Generate background if specified - ensure it's visible
    const backgroundRect = request.backgroundColor 
      ? `  <rect x="0" y="0" width="${width}" height="${height}" fill="${request.backgroundColor}" opacity="${Math.max(request.opacity, 0.8)}"/>`
      : `  <rect x="0" y="0" width="${width}" height="${height}" fill="rgba(0,0,0,0.7)"/>`;

    // Create text elements with styling and strong contrast
    const textElements = textLines.map((line, index) => {
      const yPos = y + (index * lineHeight);
      return `  <text x="${x}" y="${yPos}" fill="${request.textColor}" font-size="${request.fontSize}" font-family="Arial, sans-serif" font-weight="${request.style === 'bold' ? 'bold' : 'normal'}" text-anchor="middle" stroke="#000000" stroke-width="1" filter="url(#dropshadow)">${this.escapeXML(line)}</text>`;
    }).join('\n');

    return `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <filter id="dropshadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="2" dy="2" stdDeviation="3" flood-color="rgba(0,0,0,0.3)"/>
    </filter>
    <linearGradient id="textGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#ff6b6b"/>
      <stop offset="100%" style="stop-color:#4ecdc4"/>
    </linearGradient>
  </defs>
  <rect x="0" y="0" width="${width}" height="${height}" fill="#f0f0f0"/>
  ${backgroundRect}
  ${textElements}
</svg>`;
  }

  private wrapText(text: string, maxCharsPerLine: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';

    for (const word of words) {
      if ((currentLine + word).length <= maxCharsPerLine) {
        currentLine += (currentLine ? ' ' : '') + word;
      } else {
        if (currentLine) lines.push(currentLine);
        currentLine = word;
      }
    }
    if (currentLine) lines.push(currentLine);

    return lines;
  }

  private calculateMaxCharactersPerLine(width: number, fontSize: number): number {
    // Rough estimate: each character takes about 0.6 * fontSize pixels
    const charWidth = fontSize * 0.6;
    const maxChars = Math.floor((width * 0.8) / charWidth); // Use 80% of width for padding
    return Math.max(10, maxChars); // Minimum 10 characters
  }

  private calculateTextPosition(position: string, width: number, height: number, textHeight: number): { x: number, y: number } {
    const padding = 50;
    
    switch (position) {
      case 'top':
        return { x: width / 2, y: padding + 20 };
      case 'center':
        return { x: width / 2, y: (height - textHeight) / 2 + 20 };
      case 'bottom':
        return { x: width / 2, y: height - textHeight - padding };
      case 'top-left':
        return { x: padding, y: padding + 20 };
      case 'top-right':
        return { x: width - padding, y: padding + 20 };
      case 'bottom-left':
        return { x: padding, y: height - textHeight - padding };
      case 'bottom-right':
        return { x: width - padding, y: height - textHeight - padding };
      default:
        return { x: width / 2, y: height / 2 };
    }
  }

  private getTextStyling(style: string): string {
    switch (style) {
      case 'shadow':
        return 'filter="url(#dropshadow)"';
      case 'gradient':
        return 'fill="url(#textGradient)"';
      case 'bold':
        return 'font-weight="bold"';
      case 'minimal':
        return 'font-weight="300"';
      default:
        return '';
    }
  }

  private escapeXML(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  // Generate suggested text overlays for ad copy
  generateTextSuggestions(adCopy: any, platform: string): any[] {
    const suggestions = [];
    
    // Headlines as prominent overlays
    if (adCopy.headlines) {
      adCopy.headlines.forEach((headline: string, index: number) => {
        suggestions.push({
          id: `headline-${index}`,
          text: headline,
          style: 'bold',
          position: 'center',
          fontSize: this.getOptimalFontSize(platform, 'headline'),
          textColor: '#ffffff',
          backgroundColor: 'rgba(0,0,0,0.7)',
          opacity: 0.8,
          type: 'headline'
        });
      });
    }

    // CTAs as bottom overlays
    if (adCopy.ctas) {
      adCopy.ctas.forEach((cta: string, index: number) => {
        suggestions.push({
          id: `cta-${index}`,
          text: cta,
          style: 'shadow',
          position: 'bottom',
          fontSize: this.getOptimalFontSize(platform, 'cta'),
          textColor: '#ff6b6b',
          backgroundColor: 'rgba(255,255,255,0.9)',
          opacity: 0.9,
          type: 'cta'
        });
      });
    }

    return suggestions;
  }

  // Generate image concepts for social media graphics
  async generateImageConcepts(productName: string, productDescription: string, platforms: string[]): Promise<any> {
    try {
      const prompt = `Generate creative image concepts for social media marketing graphics for this product:

Product: ${productName}
Description: ${productDescription}

For each platform (${platforms.join(', ')}), suggest 3 different visual concepts that would work well for affiliate marketing. Focus on:

1. Visual composition ideas
2. Color schemes that convert well
3. Background concepts (lifestyle, product focus, minimalist, etc.)
4. Text overlay placement suggestions
5. Visual elements that build trust and drive clicks

Respond with structured JSON format:
{
  "concepts": [
    {
      "platform": "platform_name",
      "concept_id": 1,
      "title": "Concept Title",
      "description": "Detailed description of the visual concept",
      "visual_style": "modern/minimalist/lifestyle/product-focused",
      "color_scheme": ["#color1", "#color2", "#color3"],
      "background_type": "solid/gradient/lifestyle/product/texture",
      "text_placement": "top/center/bottom/overlay",
      "key_elements": ["element1", "element2", "element3"],
      "marketing_angle": "trust/urgency/lifestyle/features"
    }
  ]
}`;

      const response = await this.ai.models.generateContent({
        model: "gemini-2.5-pro",
        config: {
          responseMimeType: "application/json",
        },
        contents: prompt,
      });

      const result = JSON.parse(response.text || '{"concepts": []}');
      return result;
    } catch (error) {
      console.error('Error generating image concepts:', error);
      return this.generateFallbackConcepts(productName, platforms);
    }
  }

  // Fallback concepts if AI generation fails
  private generateFallbackConcepts(productName: string, platforms: string[]): any {
    const baseConcepts = [
      {
        title: "Product Showcase",
        description: "Clean product image with bold text overlay highlighting key benefits",
        visual_style: "product-focused",
        color_scheme: ["#ffffff", "#000000", "#ff6b6b"],
        background_type: "solid",
        text_placement: "bottom",
        key_elements: ["product image", "benefit text", "call-to-action"],
        marketing_angle: "features"
      },
      {
        title: "Lifestyle Context",
        description: "Product in real-world usage with lifestyle photography",
        visual_style: "lifestyle",
        color_scheme: ["#f8f9fa", "#495057", "#28a745"],
        background_type: "lifestyle",
        text_placement: "overlay",
        key_elements: ["lifestyle scene", "product in use", "social proof"],
        marketing_angle: "lifestyle"
      },
      {
        title: "Minimalist Appeal",
        description: "Clean, minimal design with strong typography and subtle product presence",
        visual_style: "minimalist",
        color_scheme: ["#ffffff", "#6c757d", "#007bff"],
        background_type: "gradient",
        text_placement: "center",
        key_elements: ["clean typography", "minimal graphics", "trust badges"],
        marketing_angle: "trust"
      }
    ];

    const concepts = platforms.flatMap((platform, platformIndex) => 
      baseConcepts.map((concept, conceptIndex) => ({
        platform,
        concept_id: conceptIndex + 1,
        ...concept
      }))
    );

    return { concepts };
  }

  private getOptimalFontSize(platform: string, textType: 'headline' | 'cta' | 'description'): number {
    const baseSizes = {
      headline: { base: 48, mobile: 36 },
      cta: { base: 32, mobile: 24 },
      description: { base: 24, mobile: 18 }
    };

    const isMobileFormat = ['instagram_story', 'tiktok_video'].includes(platform);
    return isMobileFormat ? baseSizes[textType].mobile : baseSizes[textType].base;
  }

  // Get available social media formats
  getSocialFormats(): { [key: string]: SocialGraphicDimensions } {
    return this.socialFormats;
  }
}